<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>INFORMATION → BELIEF (evenodd + X-anchor, vertical only)</title>
  <style>
    :root{ --canvas-w:1080px; --canvas-h:1920px; }
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background:#0f0f12; color:#eee;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    }
    .stage{ width:var(--canvas-w); height:var(--canvas-h); display:block; }
    #outGroup path{ shape-rendering: geometricPrecision; }
  </style>
</head>
<body>
  <svg id="svg" class="stage" viewBox="0 0 1080 1920" role="img" aria-label="INFORMATION to BELIEF morph">
    <path id="measurePath" d="M0,0Z" fill="none" stroke="none" visibility="hidden"></path>

    <g id="outGroup" fill="currentColor" stroke="none"></g>

    <!-- 중앙 BELIEF 오버레이(원본 벡터) -->
    <g id="beliefOverlay" fill="currentColor" stroke="none" fill-rule="nonzero" opacity="0"></g>
  </svg>

  <script>
    const D_INFORMATION = [
      `M0,3.71h34.46v188.74H0V3.71Z`,
      `M54.08,3.71h33.67l31.55,99.67h.53V3.71h27.57v188.74h-26.77l-36.85-114.25h-.53v114.25h-29.16V3.71Z`,
      `M168.34,3.71h77.14v29.16h-42.68v50.37h31.55v30.75h-31.55v78.47h-34.46V3.71Z`,
      `M301.94,0c30.49,0,50.37,23.59,50.37,98.08s-19.88,98.08-50.37,98.08-50.37-23.59-50.37-98.08S271.46,0,301.94,0ZM289.22,117.97c0,40.82,4.77,49.04,12.72,49.04s12.72-8.22,12.72-49.04v-39.76c0-40.82-4.77-49.04-12.72-49.04s-12.72,8.22-12.72,49.04v39.76Z`,
      `M369.54,3.71h38.7c32.87,0,54.61,13.78,54.61,53.55,0,15.91-4.77,37.11-20.15,46.13l20.41,89.07h-34.73l-16.17-81.12h-8.22v81.12h-34.46V3.71ZM404.01,83.77h6.89c12.72,0,17.5-12.72,17.5-26.24,0-20.41-7.42-26.24-19.09-26.24h-5.3v52.49Z`,
      `M476.11,3.71h45.86l15.37,96.76h.53l16.17-96.76h44.8v188.74h-30.75V54.08h-.53l-23.33,138.38h-19.09l-23.06-138.38h-.53v138.38h-25.45V3.71Z`,
      `M636.76,3.71h49.84l23.33,188.74h-33.14l-5.04-41.88h-27.83l-4.77,41.88h-28.89L636.76,3.71ZM658.76,32.87h-.53l-10.87,90.13h21.47l-10.07-90.13Z`,
      `M728.75,32.87h-29.69V3.71h93.84v29.16h-29.69v159.58h-34.46V32.87Z`,
      `M800.06,3.71h34.46v188.74h-34.46V3.71Z`,
      `M900.79,0c30.49,0,50.37,23.59,50.37,98.08s-19.88,98.08-50.37,98.08-50.37-23.59-50.37-98.08S870.31,0,900.79,0ZM888.07,117.97c0,40.82,4.77,49.04,12.72,49.04s12.72-8.22,12.72-49.04v-39.76c0-40.82-4.77-49.04-12.72-49.04s-12.72,8.22-12.72,49.04v39.76Z`,
      `M967.07,3.71h33.67l31.55,99.67h.53V3.71h27.57v188.74h-26.77l-36.85-114.25h-.53v114.25h-29.16V3.71Z`
    ];

    const D_BELIEF = [
      `M0,0h25.44c12.72,0,27.98,7,27.98,28.62,0,12.72-5.72,22.58-18.44,25.28v.32c14.15,3.34,20.67,13.2,20.67,27.51,0,20.67-13.99,31.48-29.26,31.48H0V0ZM20.67,46.43c10.33,0,13.04-4.77,13.04-14.95,0-12.88-2.7-15.1-13.04-14.95v29.89ZM20.67,96.67c12.4,0,14.31-4.93,14.31-16.7,0-10.33-2.54-16.22-14.31-16.06v32.75Z`,
      `M64.71,0h46.75v17.49h-26.08v28.94h19.24v18.44h-19.24v30.85h27.19v17.49h-47.86V0Z`,
      `M120.68,0h20.67v95.72h26.39v17.49h-47.06V0Z`,
      `M175.85,0h20.67v113.21h-20.67V0Z`,
      `M209.08,0h46.75v17.49h-26.08v28.94h19.24v18.44h-19.24v30.85h27.19v17.49h-47.86V0Z`,
      `M265.05,0h46.27v17.49h-25.6v30.21h18.92v18.44h-18.92v47.06h-20.67V0Z`
    ];

    const MAP = [
      { from:[0,1],   to:0 },
      { from:[2,3],   to:1 },
      { from:[4,5],   to:2 },
      { from:[6],     to:3 },
      { from:[7,8],   to:4 },
      { from:[9,10],  to:5 },
    ];

    const svg = document.getElementById("svg");
    const outGroup = document.getElementById("outGroup");
    const overlay = document.getElementById("beliefOverlay");
    const measurePath = document.getElementById("measurePath");

    const CANVAS_W = 1080, CANVAS_H = 1920;
    const COUNT_INFO = 10;

    const APPEAR_STAGGER = 1000;
    const PAUSE_BEFORE_MERGE = 900;

    const BASE_MERGE_MS = 9000;
    const MIN_MERGE_FACTOR = 0.35;

    const HOLD_BELIEF_MS = 5000;
    const BLACK_GAP_MS = 1000;

    const SAMPLES_TOTAL = 900;   // 조금 올림 (자기교차 완화)
    const POLISH_START = 0.70;   // 좀 더 일찍 매끈해지기 시작

    // X 이동 완전 차단
    const LOCK_X = true;

    let rafIds = [];
    function clearRafs(){ rafIds.forEach(id=>cancelAnimationFrame(id)); rafIds=[]; }
    function easeInOutSine(t){ return -(Math.cos(Math.PI * t) - 1) / 2; }

    function makePath(d){
      const p = document.createElementNS("http://www.w3.org/2000/svg","path");
      p.setAttribute("d", d);
      return p;
    }

    function splitSubpaths(d){
      const s = (d||"").trim();
      const parts = s.split(/(?=[Mm])/).map(x=>x.trim()).filter(Boolean);
      return parts.length ? parts : ["M0,0Z"];
    }

    function allocateSamplesByLength(lengths, totalSamples){
      const sum = lengths.reduce((a,b)=>a+b,0) || 1;
      let alloc = lengths.map(L => Math.max(18, Math.round((L/sum)*totalSamples)));
      let diff = totalSamples - alloc.reduce((a,b)=>a+b,0);
      let i=0;
      while(diff!==0 && alloc.length){
        const k=i%alloc.length;
        if(diff>0){ alloc[k]++; diff--; }
        else if(alloc[k]>18){ alloc[k]--; diff++; }
        i++;
      }
      return alloc;
    }

    function sampleCompoundD(d, totalSamples){
      const subs = splitSubpaths(d);
      const lengths = subs.map(sd=>{
        measurePath.setAttribute("d", sd);
        return Math.max(0.0001, measurePath.getTotalLength());
      });
      const alloc = allocateSamplesByLength(lengths, totalSamples);

      return subs.map((sd, idx)=>{
        measurePath.setAttribute("d", sd);
        const len = Math.max(0.0001, measurePath.getTotalLength());
        const n = alloc[idx];
        const pts = new Array(n);
        for(let i=0;i<n;i++){
          const p = measurePath.getPointAtLength((i/(n-1))*len);
          pts[i]=[p.x,p.y];
        }
        return pts;
      });
    }

    function contoursToD(contours){
      let d="";
      for(const pts of contours){
        if(!pts || pts.length<2) continue;
        d += `M${pts[0][0]},${pts[0][1]}`;
        for(let i=1;i<pts.length;i++) d += `L${pts[i][0]},${pts[i][1]}`;
        d += `Z`;
      }
      return d || "M0,0Z";
    }

    function normalizeContoursCount(arr, maxC){
      if(arr.length===maxC) return arr;
      const out = new Array(maxC);
      for(let i=0;i<maxC;i++){
        const idx = Math.floor((i+0.5)/maxC * arr.length);
        out[i] = arr[Math.max(0, Math.min(arr.length-1, idx))];
      }
      return out;
    }

    function bboxOfDs(ds){
      const g=document.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute("visibility","hidden");
      ds.forEach(d => g.appendChild(makePath(d)));
      svg.appendChild(g);
      const b=g.getBBox();
      g.remove();
      return b;
    }

    function centerOfBBoxInTf(bbox, tf){
      const cx = tf.x + (bbox.x + bbox.width/2) * tf.s;
      const cy = tf.y + (bbox.y + bbox.height/2) * tf.s;
      return {cx,cy};
    }

    // === X-ANCHOR 보정용: 모든 contour의 평균 x를 centroid로 사용 ===
    function centroidX(contours){
      let sum=0, cnt=0;
      for(const pts of contours){
        for(const [x] of pts){ sum+=x; cnt++; }
      }
      return cnt ? (sum/cnt) : 0;
    }

    function animateOverlayPolish(ms){
      const t0=performance.now();
      function frame(now){
        const t = Math.min(1, Math.max(0,(now-t0)/ms));
        const p = (t <= POLISH_START) ? 0 : (t - POLISH_START) / (1 - POLISH_START);
        const e = easeInOutSine(Math.min(1, Math.max(0, p)));
        overlay.setAttribute("opacity", String(e));
        if(t<1) requestAnimationFrame(frame);
        else overlay.setAttribute("opacity","1");
      }
      requestAnimationFrame(frame);
    }

    // y축 위주 transform (x는 고정)
    function animateVerticalTransform(g, from, to, ms){
      const t0=performance.now();
      function frame(now){
        const t=Math.min(1, Math.max(0,(now-t0)/ms));
        const e=easeInOutSine(t);

        const x = LOCK_X ? from.x : (from.x + (to.x-from.x)*e);
        const y = from.y + (to.y-from.y)*e;
        const s = from.s + (to.s-from.s)*e;

        g.setAttribute("transform", `translate(${x} ${y}) scale(${s})`);

        if(t<1) rafIds.push(requestAnimationFrame(frame));
        else g.setAttribute("transform", `translate(${LOCK_X?from.x:to.x} ${to.y}) scale(${to.s})`);
      }
      rafIds.push(requestAnimationFrame(frame));
    }

    // 모핑: evenodd + X-ANCHOR 보정(오른쪽 튐 제거)
    function morphWithXAnchor(outPath, fromContours, toContours, ms){
      const maxC = Math.max(fromContours.length, toContours.length);
      const A = normalizeContoursCount(fromContours, maxC);
      const B = normalizeContoursCount(toContours, maxC);

      const anchor = centroidX(fromContours);
      const t0=performance.now();

      function frame(now){
        const t = Math.min(1, Math.max(0,(now-t0)/ms));
        const e = easeInOutSine(t);

        const outContours = new Array(maxC);
        for(let c=0;c<maxC;c++){
          const a=A[c], b=B[c];
          const n=Math.min(a.length,b.length);
          const pts=new Array(n);
          for(let i=0;i<n;i++){
            const ax=a[i][0], ay=a[i][1];
            const bx=b[i][0], by=b[i][1];
            pts[i]=[ax+(bx-ax)*e, ay+(by-ay)*e];
          }
          outContours[c]=pts;
        }

        // X drift 보정
        const cur = centroidX(outContours);
        const dx = anchor - cur;
        outPath.setAttribute("transform", `translate(${dx} 0)`);

        outPath.setAttribute("d", contoursToD(outContours));

        if(t<1) rafIds.push(requestAnimationFrame(frame));
        else outPath.setAttribute("transform", `translate(${anchor - centroidX(outContours)} 0)`);
      }
      rafIds.push(requestAnimationFrame(frame));
    }

    function runCycle(){
      clearRafs();
      outGroup.style.display="";
      outGroup.innerHTML="";
      overlay.innerHTML="";
      overlay.setAttribute("opacity","0");

      const infoBBox = bboxOfDs(D_INFORMATION);
      const beliefBBox = bboxOfDs(D_BELIEF);

      // layout
      const paddingX=40, paddingY=60;
      const availableW = CANVAS_W - paddingX*2;
      const availableH = CANVAS_H - paddingY*2;

      const scaleByHeight = (availableH/COUNT_INFO)/infoBBox.height;
      const scaleByWidth  = availableW/infoBBox.width;
      const INFO_SCALE = Math.min(scaleByHeight, scaleByWidth);
      const slotH = infoBBox.height * INFO_SCALE;

      function infoTfForIndex(i){
        const x = paddingX + (availableW - infoBBox.width*INFO_SCALE)/2 - infoBBox.x*INFO_SCALE;
        const y = paddingY + i*slotH - infoBBox.y*INFO_SCALE;
        return {x,y,s:INFO_SCALE};
      }

      function beliefTfCentered(){
        const pad=60;
        const availW = CANVAS_W - pad*2;
        const availH = CANVAS_H - pad*2;
        const s = Math.min(availW/beliefBBox.width, availH/beliefBBox.height);
        const x = (CANVAS_W - beliefBBox.width*s)/2 - beliefBBox.x*s;
        const y = (CANVAS_H - beliefBBox.height*s)/2 - beliefBBox.y*s;
        return {x,y,s};
      }
      const BELIEF_TF = beliefTfCentered();

      // overlay BELIEF
      overlay.setAttribute("transform", `translate(${BELIEF_TF.x} ${BELIEF_TF.y}) scale(${BELIEF_TF.s})`);
      D_BELIEF.forEach(d => overlay.appendChild(makePath(d)));

      const beliefCenter = centerOfBBoxInTf(beliefBBox, BELIEF_TF);

      function infoCenter(tf){ return centerOfBBoxInTf(infoBBox, tf); }

      // instances
      const instances=[];
      for(let i=0;i<COUNT_INFO;i++){
        const tf = infoTfForIndex(i);
        const g = document.createElementNS("http://www.w3.org/2000/svg","g");
        g.setAttribute("transform", `translate(${tf.x} ${tf.y}) scale(${tf.s})`);
        g.style.display="none";
        outGroup.appendChild(g);

        // 모핑용 path 6개만 미리 만들어두고(초기엔 hidden), appear 중에는 원본 단어 11개를 보여줌
        const rawWord = document.createElementNS("http://www.w3.org/2000/svg","g");
        rawWord.setAttribute("fill-rule","nonzero");
        for(const d of D_INFORMATION) rawWord.appendChild(makePath(d));
        g.appendChild(rawWord);

        const morphParts = MAP.map(()=> {
          const p = document.createElementNS("http://www.w3.org/2000/svg","path");
          // ✅ 모핑 중 자기교차 문제 완화
          p.setAttribute("fill-rule","evenodd");
          p.style.display="none";
          g.appendChild(p);
          return p;
        });

        instances.push({ g, tf, rawWord, morphParts });
      }

      // appear
      for(let i=0;i<COUNT_INFO;i++){
        setTimeout(()=>{ instances[i].g.style.display=""; }, i*APPEAR_STAGGER);
      }
      const totalAppearTime = (COUNT_INFO-1)*APPEAR_STAGGER;

      // merge
      setTimeout(()=>{
        clearRafs();
        animateOverlayPolish(BASE_MERGE_MS);

        // maxDist
        const dists = instances.map(inst=>{
          const c = infoCenter(inst.tf);
          return Math.hypot(c.cx - beliefCenter.cx, c.cy - beliefCenter.cy);
        });
        const maxDist = Math.max(...dists, 1);

        for(let i=0;i<COUNT_INFO;i++){
          const inst = instances[i];
          const c = infoCenter(inst.tf);
          const dist = Math.hypot(c.cx - beliefCenter.cx, c.cy - beliefCenter.cy);
          const dur = Math.max(BASE_MERGE_MS*MIN_MERGE_FACTOR, BASE_MERGE_MS*(dist/maxDist));

          // 이동: y만
          animateVerticalTransform(inst.g, inst.tf, BELIEF_TF, dur);

          // raw 숨기고 morph 표시
          inst.rawWord.style.display="none";

          // 각 파트 모핑
          for(let k=0;k<MAP.length;k++){
            const m = MAP[k];
            const outP = inst.morphParts[k];
            outP.style.display="";

            const fromContours = m.from
              .map(ii => sampleCompoundD(D_INFORMATION[ii], Math.floor(SAMPLES_TOTAL / m.from.length)))
              .flat();

            const toContours = sampleCompoundD(D_BELIEF[m.to], SAMPLES_TOTAL);

            // 시작값은 폴리곤 d로
            outP.setAttribute("d", contoursToD(fromContours));
            outP.setAttribute("transform","translate(0 0)");

            morphWithXAnchor(outP, fromContours, toContours, dur);
          }
        }

        setTimeout(()=>{
          outGroup.style.display="none";
          overlay.setAttribute("opacity","0");
          setTimeout(()=>runCycle(), BLACK_GAP_MS);
        }, BASE_MERGE_MS + HOLD_BELIEF_MS);

      }, totalAppearTime + PAUSE_BEFORE_MERGE);
    }

    runCycle();
  </script>
</body>
</html>
