<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Information → Media → Perspective → Belief (Morph)</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@800&display=swap" rel="stylesheet">

<style>
  html, body { margin:0; padding:0; background:#000; overflow:hidden; height:100%; }

  .media-band{
    position: fixed; left: 0; top: calc(100vh / 6);
    width: 100vw; height: 120px;
    display: flex; align-items: center; overflow: hidden;
    pointer-events: none; z-index: 10;
    opacity: 1;
    transition: opacity 5000ms linear;
  }

  .media-rail{
    display: flex;
    white-space: nowrap;
    opacity: 0.95;
    transform: translate3d(0,0,0);
    will-change: transform;
    -webkit-font-smoothing: antialiased;
    text-rendering: geometricPrecision;
  }

  .rail-track{
    display: inline-flex;
    gap: 42px;
    color: #fff;
    font-family: system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
    font-weight: 900;
    font-size: 72px;
    letter-spacing: -0.04em;
  }

  .drop{
    position: absolute; top: -140px; left: 0;
    transform: translate3d(0,0,0); will-change: transform;
    font-family: system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
    font-weight: 900; font-size: 64px; letter-spacing: -0.02em; color: #fff;
    user-select:none; pointer-events:none; z-index:2; white-space:nowrap;
    -webkit-font-smoothing: antialiased;
    text-rendering: geometricPrecision;
  }

  .belief-word{
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    color: #ff0000;
    font-family: "Nanum Myeongjo", serif;
    font-weight: 800;
    letter-spacing: -0.06em;
    line-height: 1;
    opacity: 0;
    z-index: 40;
    pointer-events: none;
    /* 신념 출현 속도 조절 (opacity) */
    transition: opacity 3000ms ease;
    -webkit-font-smoothing: antialiased;
    text-rendering: geometricPrecision;
    white-space: pre-line;
    text-align: center;
  }
  .belief-word.show{ opacity: 1; }

  /* 루프 전환용 검정 오버레이 */
  #blackOverlay{
    position: fixed;
    inset: 0;
    background: #000;
    opacity: 1;                 /* 시작은 검정(= 페이드 인 준비) */
    pointer-events: none;
    z-index: 9999;
    transition: opacity 2000ms ease;  /* 페이드 속도 */
  }
  #blackOverlay.off{ opacity: 0; }
</style>
</head>
<body>

<div class="media-band" id="mediaBand">
  <div class="media-rail" id="mediaRail"></div>
</div>

<div class="belief-word" id="beliefWord">신
념</div>

<!-- 루프 전환용 오버레이 -->
<div id="blackOverlay"></div>

<script>
/* 정보 생성 속도 */
const SPAWN_EVERY_MS = 500;
const BURST_CHANCE = 0.28;
const BURST_MIN = 2;
const BURST_MAX = 4;

const COL_WIDTH = 64;
const JITTER_X = 0;

const END_DELAY_MS = 5000;

const FLOOR_SNAP = 0;
const FLOOR_OFFSET = 150;

const CRAZY_DURATION_MS = 10000;
const COLLAPSE_MS = 1000;
const BELIEF_SHOW_AT_MS = 1200;

/* 신념 폰트 크기 */
const BELIEF_SCALE = 0.10;

/* 루핑: 신념 유지/페이드 후 리셋 */
const BELIEF_HOLD_MS = 10000;  // 신념이 완전히 나타난 뒤 유지 시간(10초)
const BELIEF_FADE_MS = 3000;   // CSS transition(opacity)와 동일하게 맞추기

/* 루프 전환용 오버레이 */
const OVERLAY_FADE_MS = 2000; // CSS(#blackOverlay transition)와 맞추기

/* 루프 시작 시 mediaBand도 부드럽게 등장 */
const MEDIA_FADEIN_MS = 1200;

let drops = [];
let lastSpawn = 0;
let lastTime = performance.now();
let railOffset = 0;

let railLoopW = 0;
let railSpeed = 26;

const piles = new Map();

let endArmed = false;
let endStartMs = 0;

let morphing = false;
let morphStartMs = 0;
let collapsed = false;
let collapseStartMs = 0;

/* 루프 상태 */
let beliefShownAt = 0;
let beliefFadeStarted = false;
let beliefFadeStartAt = 0;
let beliefShowTimeoutId = null;

let resetScheduled = false;

function rand(min, max){ return min + Math.random() * (max - min); }
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function overlayOn(){
  const ov = document.getElementById("blackOverlay");
  ov.classList.remove("off"); // opacity 1
}
function overlayOff(){
  const ov = document.getElementById("blackOverlay");
  ov.classList.add("off");    // opacity 0
}

/* 루프 시작에 mediaBand를 살짝 페이드인 */
function mediaBandFadeIn(){
  const band = document.getElementById("mediaBand");
  band.style.transition = `opacity ${MEDIA_FADEIN_MS}ms ease`;
  band.style.opacity = "1";
  // transition을 원래대로 돌려놓기(armEnding의 5초 페이드 유지)
  setTimeout(() => {
    band.style.transition = "opacity 5000ms linear";
  }, MEDIA_FADEIN_MS + 60);
}

function buildRail(){
  const rail = document.getElementById("mediaRail");
  rail.innerHTML = "";

  const word = "뉴스 인스타그램 신문 책 틱톡 유튜브 팟캐스트 블로그 잡지 쓰레드";

  const track = document.createElement("div");
  track.className = "rail-track";

  const approxPerSpan = 560;
  const repeatCount = Math.ceil(window.innerWidth / approxPerSpan) + 6;

  for(let i=0;i<repeatCount;i++){
    const span = document.createElement("span");
    span.textContent = word;
    track.appendChild(span);
  }

  const track2 = track.cloneNode(true);
  rail.appendChild(track);
  rail.appendChild(track2);

  requestAnimationFrame(() => {
    railLoopW = track.getBoundingClientRect().width;
    if (!railLoopW){
      requestAnimationFrame(() => { railLoopW = track.getBoundingClientRect().width; });
    }
  });
}

function getMediaCenterY(){
  const band = document.getElementById("mediaBand");
  const r = band.getBoundingClientRect();
  return r.top + r.height / 2;
}
function getMediaUnderlineY(){
  const rail = document.getElementById("mediaRail");
  const r = rail.getBoundingClientRect();
  return r.bottom;
}

function colIndexForX(x){ return Math.floor(x / COL_WIDTH); }
function getColPileTopY(col){
  const h = piles.get(col) || 0;
  return (window.innerHeight + FLOOR_OFFSET) - h;
}

function pickSpawnX(size){
  const bands = Math.max(8, Math.floor(window.innerWidth / 160));
  const bandW = window.innerWidth / bands;
  const band = Math.floor(Math.random() * bands);
  const base = band * bandW + bandW * 0.5;
  const x = base + rand(-bandW * 0.35, bandW * 0.35) - size;
  return clamp(x, 0, window.innerWidth - size * 2);
}

function spawnDrop(){
  const el = document.createElement("div");
  el.className = "drop";
  el.textContent = "정보";

  const size = Math.round(rand(50, 76));
  el.style.fontSize = size + "px";

  const x = pickSpawnX(size);
  const y = rand(-160, -40);

  const vy = rand(220, 520);
  const vx = rand(-8, 8);

  el.style.opacity = rand(0.85, 1);
  document.body.appendChild(el);

  drops.push({
    el,
    x, y,
    vx, vy,

    mx: 0, my: 0,
    mvx: 0, mvy: 0,
    seed: Math.random() * 1000,
    phase: Math.random() * Math.PI * 2,

    converted: false,
    size,
    landed: false,
    col: null,

    h: size * 1.25
  });
}

function randomNonWhiteRGB(){
  let r, g, b, luminance;
  do {
    r = Math.floor(Math.random() * 256);
    g = Math.floor(Math.random() * 256);
    b = Math.floor(Math.random() * 256);
    luminance = 0.299*r + 0.587*g + 0.114*b;
  } while (luminance > 235);
  return `rgb(${r}, ${g}, ${b})`;
}

function convertToPerspective(d){
  d.converted = true;
  d.el.textContent = "관점";
  d.el.style.color = randomNonWhiteRGB();
  d.el.style.transition = "none";
  d.el.style.filter = "none";
}

function landIntoPile(d, col, pileTopY){
  d.landed = true;
  d.vy = 0;
  d.vx = 0;
  d.col = col;

  if (JITTER_X) d.x += rand(-JITTER_X, JITTER_X);

  d.y = pileTopY - d.h + FLOOR_SNAP;

  const currentH = piles.get(col) || 0;
  piles.set(col, currentH + d.h);

  d.el.style.transition = "transform 120ms ease-out";
  d.el.style.transform = `translate3d(${d.x}px, ${d.y}px, 0) scale(1.06, 0.90)`;
  setTimeout(() => {
    if (!d.el) return;
    d.el.style.transition = "transform 160ms ease-out";
    d.el.style.transform = `translate3d(${d.x}px, ${d.y}px, 0) scale(1)`;
    d.el.style.filter = "none";
  }, 140);
}

function getPileTopY(){
  let maxH = 0;
  for (const h of piles.values()) maxH = Math.max(maxH, h);
  return window.innerHeight - maxH;
}

function armEnding(now){
  if (endArmed || morphing) return;
  endArmed = true;
  endStartMs = now;

  const band = document.getElementById("mediaBand");
  band.style.opacity = "0";
}

function computeMaxFontSizeForWord(el, text){
  el.textContent = text;

  const padX = 36, padY = 36;
  const maxW = window.innerWidth - padX * 2;
  const maxH = window.innerHeight - padY * 2;

  let lo = 24, hi = 2400, best = 24;

  const prevDisplay = el.style.display;
  const prevOpacity = el.style.opacity;

  el.style.display = "block";
  el.style.opacity = "0";

  while (lo <= hi){
    const mid = (lo + hi) >> 1;
    el.style.fontSize = mid + "px";
    const r = el.getBoundingClientRect();
    const ok = (r.width <= maxW) && (r.height <= maxH);
    if (ok){ best = mid; lo = mid + 1; }
    else { hi = mid - 1; }
  }

  el.style.opacity = prevOpacity;
  el.style.display = prevDisplay || "";
  return best;
}

function startCrazyMorph(now){
  if (morphing) return;
  morphing = true;
  morphStartMs = now;

  const band = document.getElementById("mediaBand");
  band.style.display = "none";

  for (const d of drops){
    if (!d.el) continue;
    if (!d.converted){
      d.el.remove();
      d.el = null;
      continue;
    }

    d.landed = true;
    d.mx = d.x;
    d.my = d.y;

    d.mvx = rand(-420, 420);
    d.mvy = rand(-420, 420);

    d.el.style.transition = "none";
    d.el.style.filter = "blur(0px)";
    d.el.style.opacity = "1";
  }

  const belief = document.getElementById("beliefWord");
  belief.textContent = "신념";
  belief.style.fontSize = (computeMaxFontSizeForWord(belief, "신념") * BELIEF_SCALE) + "px";
  belief.classList.remove("show");

  beliefShownAt = 0;
  beliefFadeStarted = false;
  beliefFadeStartAt = 0;
  resetScheduled = false;

  if (beliefShowTimeoutId) clearTimeout(beliefShowTimeoutId);
  beliefShowTimeoutId = null;
}

function updateCrazyMorph(now, dt){
  const t = (now - morphStartMs) / CRAZY_DURATION_MS;
  const p = clamp(t, 0, 1);

  const cx = window.innerWidth / 2;
  const cy = window.innerHeight / 2;

  const speedRamp = 1 + 2.8 * Math.pow(p, 1.35);

  const attract = (55 + 320 * (p*p)) * speedRamp;
  const swirl  = (180 + 260 * (1 - p)) * speedRamp;
  const chaos  = (680 * (1 - p*0.45)) * speedRamp;

  const damp = 0.992 - 0.012 * p;

  const repelRadius = 118;
  const repelK = (1200 + 2200 * p) * speedRamp;
  const restitution = 1.18 + 0.22 * p;
  const friction = 0.985;

  const actives = [];
  for (const d of drops){
    if (d && d.el && d.converted) actives.push(d);
  }
  const cap = Math.min(actives.length, 160);

  for (let i = 0; i < actives.length; i++){
    const a = actives[i];

    let dx = (cx - (a.mx + a.size*0.2));
    let dy = (cy - (a.my + a.size*0.55));
    const dist = Math.hypot(dx, dy) + 0.0001;
    const ndx = dx / dist;
    const ndy = dy / dist;

    a.mvx += ndx * attract * dt;
    a.mvy += ndy * attract * dt;

    const sgn = (Math.sin(a.seed + now * 0.0014) > 0) ? 1 : -1;
    a.mvx += (-ndy) * swirl * dt * sgn;
    a.mvy += ( ndx) * swirl * dt * sgn;

    const n1 = Math.sin(a.seed + now * 0.008 + a.phase);
    const n2 = Math.cos(a.seed * 0.7 + now * 0.010 - a.phase);
    a.mvx += (n1 * chaos) * dt;
    a.mvy += (n2 * chaos) * dt;

    const vmax = (880 + 900 * p) * speedRamp;
    a.mvx = clamp(a.mvx, -vmax, vmax);
    a.mvy = clamp(a.mvy, -vmax, vmax);
  }

  // 충돌/튕김
  for (let i = 0; i < cap; i++){
    const a = actives[i];
    for (let j = i + 1; j < cap; j++){
      const b = actives[j];

      const rx = a.mx - b.mx;
      const ry = a.my - b.my;
      const rd = Math.hypot(rx, ry) + 0.0001;
      if (rd > repelRadius) continue;

      const nx = rx / rd;
      const ny = ry / rd;

      const overlap = (1 - (rd / repelRadius));
      const push = repelK * overlap;

      a.mvx += nx * push * dt;
      a.mvy += ny * push * dt;
      b.mvx -= nx * push * dt;
      b.mvy -= ny * push * dt;

      const rvx = a.mvx - b.mvx;
      const rvy = a.mvy - b.mvy;
      const relN = rvx * nx + rvy * ny;
      if (relN < 0){
        const jimp = -(1 + restitution) * relN * 0.5;
        a.mvx += nx * jimp;
        a.mvy += ny * jimp;
        b.mvx -= nx * jimp;
        b.mvy -= ny * jimp;

        const tx = -ny, ty = nx;
        const relT = rvx * tx + rvy * ty;
        const jt = -relT * (1 - friction) * 0.5;
        a.mvx += tx * jt;
        a.mvy += ty * jt;
        b.mvx -= tx * jt;
        b.mvy -= ty * jt;
      }
    }
  }

  // 적분 + 경계 + 시각
  for (let i = 0; i < actives.length; i++){
    const a = actives[i];

    a.mx += a.mvx * dt;
    a.my += a.mvy * dt;

    a.mvx *= damp;
    a.mvy *= damp;

    const pad = 140;
    const minX = -pad, maxX = window.innerWidth + pad;
    const minY = -pad, maxY = window.innerHeight + pad;

    if (a.mx < minX){ a.mx = minX; a.mvx *= -1.08; }
    if (a.mx > maxX){ a.mx = maxX; a.mvx *= -1.08; }
    if (a.my < minY){ a.my = minY; a.mvy *= -1.08; }
    if (a.my > maxY){ a.my = maxY; a.mvy *= -1.08; }

    const wobAmp = 0.14 + 0.18 * p;
    const wob = 1 + wobAmp * Math.sin(now * (0.010 + 0.010*p) + a.seed);
    const blur = (0.9 * (1 - p)) * (0.5 + 0.5*Math.sin(now*(0.008 + 0.006*p) + a.seed));

    a.el.style.filter = `blur(${blur.toFixed(2)}px)`;
    a.el.style.transform = `translate3d(${a.mx}px, ${a.my}px, 0) scale(${wob.toFixed(3)})`;
  }

  if (!collapsed && (now - morphStartMs >= CRAZY_DURATION_MS)){
    collapsed = true;
    collapseStartMs = now;

    for (const d of drops){
      if (!d || !d.el || !d.converted) continue;

      d.el.style.transition =
        `opacity ${COLLAPSE_MS}ms ease,
         filter ${COLLAPSE_MS}ms ease`;

      d.el.style.filter = "blur(0px)";
      d.el.style.opacity = "0";
    }

    const belief = document.getElementById("beliefWord");
    if (beliefShowTimeoutId) clearTimeout(beliefShowTimeoutId);
    beliefShowTimeoutId = setTimeout(() => {
      belief.classList.add("show");
      beliefShownAt = performance.now(); // 여기부터 10초 유지 카운트 시작
    }, BELIEF_SHOW_AT_MS);
  }

  if (collapsed && (now - collapseStartMs >= COLLAPSE_MS + 120)){
    for (const d of drops){
      if (d && d.el){
        d.el.remove();
        d.el = null;
      }
    }
  }
}

/* 루프용: 모든 상태를 초기 화면으로 리셋 */
function resetToStart(now){
  if (beliefShowTimeoutId) clearTimeout(beliefShowTimeoutId);
  beliefShowTimeoutId = null;

  for (const d of drops){
    if (d && d.el){
      d.el.remove();
      d.el = null;
    }
  }
  drops = [];
  piles.clear();

  endArmed = false;
  endStartMs = 0;

  morphing = false;
  morphStartMs = 0;

  collapsed = false;
  collapseStartMs = 0;

  beliefShownAt = 0;
  beliefFadeStarted = false;
  beliefFadeStartAt = 0;

  resetScheduled = false;

  // 미디어 밴드 원복 (오버레이 아래에서 0으로 만들고, 열릴 때 페이드인)
  const band = document.getElementById("mediaBand");
  band.style.display = "flex";
  band.style.opacity = "0";

  // 신념 원복
  const belief = document.getElementById("beliefWord");
  belief.classList.remove("show");
  belief.style.opacity = "";
  belief.textContent = "신\n념";
  belief.style.fontSize = (computeMaxFontSizeForWord(belief, "신\n념") * BELIEF_SCALE) + "px";

  railOffset = 0;
  lastSpawn = now;
  lastTime = now;

  document.documentElement.style.backgroundColor = "#000";
  document.body.style.backgroundColor = "#000";

  buildRail();
}

function scheduleResetWithOverlay(){
  if (resetScheduled) return;
  resetScheduled = true;

  overlayOn();

  setTimeout(() => {
    const n = performance.now();
    resetToStart(n);

    // reset 직후 살짝 텀(깜빡임 방지) → mediaBand 먼저 페이드인 준비 → 오버레이 열기
    setTimeout(() => {
      mediaBandFadeIn();
      overlayOff();
    }, 80);

  }, OVERLAY_FADE_MS);
}

function tick(now){
  const dt = Math.min(0.033, (now - lastTime) / 1000);
  lastTime = now;

  if (morphing){
    updateCrazyMorph(now, dt);

    // 신념이 나타난 뒤 10초 유지 → fade out → 오버레이로 덮고 리셋 → fade in
    if (beliefShownAt > 0){
      if (!beliefFadeStarted && (now - beliefShownAt >= BELIEF_HOLD_MS)){
        beliefFadeStarted = true;
        beliefFadeStartAt = now;

        const belief = document.getElementById("beliefWord");
        belief.classList.remove("show");
      }

      if (beliefFadeStarted && (now - beliefFadeStartAt >= BELIEF_FADE_MS + 120)){
        scheduleResetWithOverlay();
      }
    }

    requestAnimationFrame(tick);
    return;
  }

  if (!endArmed){
    const rail = document.getElementById("mediaRail");
    railOffset -= railSpeed * dt;
    if (railLoopW > 0){
      while (railOffset <= -railLoopW) railOffset += railLoopW;
    }
    rail.style.transform = `translate3d(${railOffset}px, 0, 0)`;
  }

  if (!endArmed && (now - lastSpawn > SPAWN_EVERY_MS)){
    const burst = (Math.random() < BURST_CHANCE);
    const n = burst ? Math.floor(rand(BURST_MIN, BURST_MAX + 1)) : 1;
    for(let i=0;i<n;i++) spawnDrop();
    lastSpawn = now;
  }

  const mediaCenterY = getMediaCenterY();
  const mediaUnderlineY = getMediaUnderlineY();

  for (let i = drops.length - 1; i >= 0; i--){
    const d = drops[i];
    if (!d || !d.el) continue;
    if (d.landed) continue;

    d.y += d.vy * dt;
    d.x += d.vx * dt;

    if (d.x < -400) d.x = window.innerWidth + 360;
    if (d.x > window.innerWidth + 400) d.x = -360;

    const glyphMidY = d.y + d.size * 0.55 - 150;
    if (!d.converted && glyphMidY >= mediaCenterY){
      convertToPerspective(d);
    }

    if (d.converted){
      const col = colIndexForX(d.x);
      const pileTopY = getColPileTopY(col);
      const bottomY = d.y + d.h;

      if (bottomY >= pileTopY){
        d.y = pileTopY - d.h + FLOOR_SNAP;
        landIntoPile(d, col, pileTopY);
      }
    } else {
      if (d.y > window.innerHeight + 240){
        d.el.remove();
        drops.splice(i, 1);
        continue;
      }
    }

    d.el.style.transform = `translate3d(${d.x}px, ${d.y}px, 0)`;
  }

  if (!endArmed){
    const pileTopGlobal = getPileTopY();
    if (pileTopGlobal <= mediaUnderlineY + 200){
      armEnding(now);
    }
  } else {
    if (now - endStartMs >= END_DELAY_MS){
      startCrazyMorph(now);
    }
  }

  requestAnimationFrame(tick);
}

buildRail();

/* 첫 화면도 부드럽게 시작 */
overlayOn();
setTimeout(() => {
  // 처음 시작할 때 mediaBand도 천천히 올라오게
  const band = document.getElementById("mediaBand");
  band.style.opacity = "0";
  mediaBandFadeIn();
  overlayOff();
}, 80);

window.addEventListener("resize", () => {
  buildRail();
  if (!morphing){
    piles.clear();
  }
  const belief = document.getElementById("beliefWord");
  belief.style.fontSize = (computeMaxFontSizeForWord(belief, "신\n념") * BELIEF_SCALE) + "px";
});

requestAnimationFrame(tick);
</script>
</body>
</html>
